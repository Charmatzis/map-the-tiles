{
  "version": 3,
  "sources": [
    "../../../../usr/local/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "/home/gaganb/projects/map-the-tiles/map-the-tiles.js",
    "/home/gaganb/projects/map-the-tiles/node_modules/rectangles-intersect/node_modules/check-point-in-rectangle/check-point-in-rectangle.js",
    "/home/gaganb/projects/map-the-tiles/node_modules/rectangles-intersect/node_modules/line-segments-intersect/line-segments-intersect.js",
    "/home/gaganb/projects/map-the-tiles/node_modules/rectangles-intersect/rectangles-intersect.js",
    "/home/gaganb/projects/map-the-tiles/node_modules/transformatrix/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "// map-the-tiles.js\nvar TransformMatrix = require('transformatrix'),\n  intersect = require('rectangles-intersect');\nvar MapTheTiles = function (viewportSize,projExtent,tileSize) {\n  this.vpSize = viewportSize || {width: 256, height: 256};\n  // default spherical mercator project extent\n  this.projExtent = projExtent || { \n    left: -20037508.342789244,\n    right: 20037508.342789244,\n    bottom: -20037508.342789244,\n    top: 20037508.342789244\n  };\n  this.tSize = tileSize || 256;\n  this.maxRes = Math.min(\n    Math.abs(this.projExtent.right - this.projExtent.left)/this.tSize,\n    Math.abs(this.projExtent.top - this.projExtent.bottom)/this.tSize);\n}\nMapTheTiles.prototype.getTiles = function(ctr, z, rot) {\n  // all calculation are in pixel coordinates i.e. project extent devied by \n  // resolution at that zoom level\n  var vpExtPx = this._getExtentPx(ctr,z), //view port extent in pixel\n    ctrPx = this._pointToPx(ctr,z), //center in pixel\n    tr, // instance of TransformMatrix used for rotated view calculation\n    rotViewportPx, // rotated view port corner coordinates in pixel\n    // expandedExtPx: rotated view port extent (MBR) in pixel, if rotation \n    // is 0 then equals to view port extent\n    expandedExtPx = vpExtPx,\n    xLeft, xRight, yBottom, yTop, top, left,\n    tiles = [];\n  if(rot && rot !=0) {\n    rot = -rot; //to follow the HTML (transform) convention clockwise positive\n    tr = new TransformMatrix();\n    tr.translate(ctrPx.x, ctrPx.y);\n    tr.rotate(Math.PI/180 * rot); //as rot is in deg\n    tr.translate(-ctrPx.x, -ctrPx.y);\n    rotViewportPx = [\n      tr.transformPoint(vpExtPx.left,vpExtPx.bottom),\n      tr.transformPoint(vpExtPx.right,vpExtPx.bottom),\n      tr.transformPoint(vpExtPx.right,vpExtPx.top),\n      tr.transformPoint(vpExtPx.left,vpExtPx.top)\n    ];\n    expandedExtPx = getBBox(rotViewportPx);\n  }\n  // tile numbers\n  xLeft = Math.floor(expandedExtPx.left/this.tSize);\n  xRight = Math.floor(expandedExtPx.right/this.tSize);\n  yBottom = Math.floor(expandedExtPx.bottom/this.tSize);\n  yTop = Math.floor(expandedExtPx.top/this.tSize);\n  //top left tile position of top-left tile with respect to window/div \n  top = topStart = Math.round((yTop * this.tSize) - vpExtPx.top);\n  left = Math.round((xLeft * this.tSize) - vpExtPx.left);\n  for (var i=xLeft; i<=xRight; i++) {\n    top = topStart;\n    for(var j=yTop; j<=yBottom; j++) {\n      tiles.push({x:i, y:j, z:z, top: top, left: left});\n      top += this.tSize;\n    }\n    left += this.tSize;\n  }\n  if(rot && rot != 0) {\n    // filters out tiles (from expanded view port) that do not intersect with\n    // view port \n    tiles = tiles.filter(function(t) {\n      return intersect(rotViewportPx,this._getTileBoundingRect(t));\n    },this);\n  }\n  return tiles;\n};\n\nMapTheTiles.prototype._getExtentPx = function(ctr,z) {\n  var res = this.maxRes/Math.pow(2,z);\n  return {\n    left: (ctr.x - this.projExtent.left)/res - this.vpSize.width/2,\n    right: (ctr.x - this.projExtent.left)/res + this.vpSize.width/2,\n    bottom: (this.projExtent.top - ctr.y)/res + this.vpSize.height/2,\n    top: (this.projExtent.top - ctr.y)/res - this.vpSize.height/2\n  };\n};\nMapTheTiles.prototype._pointToPx = function(pt,z) {\n  var res = this.maxRes/Math.pow(2,z);\n  return {\n    x: (pt.x - this.projExtent.left)/res,\n    y: (this.projExtent.top - pt.y)/res\n  };\n};\nMapTheTiles.prototype._getTileBoundingRect = function(t) {\n  var res, l, r, t, b;\n  res = this.maxRes/Math.pow(2,t.z);\n  l = t.x * this.tSize;\n  r = l + this.tSize;\n  t = t.y * this.tSize;\n  b = t + this.tSize;\n  return [[l,b], [r,b], [r,t], [l,t]];\n};\nfunction getBBox(points) {\n  var xArray = points.map(function(p) {return p[0];});\n  var yArray = points.map(function(p) {return p[1];});\n  return {\n    left: Math.min.apply(this,xArray),\n    right: Math.max.apply(this,xArray),\n    bottom: Math.max.apply(this,yArray),\n    top: Math.min.apply(this,yArray)\n  };\n}\nmodule.exports = MapTheTiles;\n",
    "// check-point-in-rectangle.js\n// check point intersects with rectangle\n// http://martin-thoma.com/how-to-check-if-a-point-is-inside-a-rectangle/\nfunction pointInRect(pt,rect,precision) {\n  var p = precision || 6;\n  var rectArea = 0.5*Math.abs(\n    (rect[0][1] - rect[2][1]) * (rect[3][0] - rect[1][0])\n    + (rect[1][1] - rect[3][1]) * (rect[0][0] - rect[2][0])\n  );\n  var triangleArea = rect.reduce(function(prev,cur, i, arr) {\n    var j = i == arr.length-1 ? 0 : i+1;\n    return prev + 0.5*Math.abs(\n      pt[0] * (arr[i][1] - arr[j][1])\n      + arr[i][0] * (arr[j][1] - pt[1])\n      + arr[j][0] * (pt[1] - arr[i][1])\n    );\n  }, 0);\n  return fix(triangleArea,p) == fix(rectArea,p);\n}\n// fix to the precision\nfunction fix(n,p) {\n  return parseInt(n * Math.pow(10,p));\n};\n\nmodule.exports = pointInRect;\n",
    "// line-segments-intersect.js \n// intersection point https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n// line 1: x1,y1,x2,y2\n// line 2: x3,y3,x4,y4\n// for comparing the float number, fixing the number to int to required \n// precision\nfunction linesIntersect(seg1, seg2, precision) {\n  var x1 = seg1[0][0],\n    y1 = seg1[0][1],\n    x2 = seg1[1][0],\n    y2 = seg1[1][1],\n    x3 = seg2[0][0],\n    y3 = seg2[0][1],\n    x4 = seg2[1][0],\n    y4 = seg2[1][1],\n    intPt,x,y,result = false, \n    p = precision || 6,\n    denominator = (x1 - x2)*(y3 - y4) - (y1 -y2)*(x3 - x4);\n  if (denominator == 0) {\n    // check both segments are Coincident, we already know \n    // that these two are parallel \n    if (fix((y3 - y1)*(x2 - x1),p) == fix((y2 -y1)*(x3 - x1),p)) {\n      // second segment any end point lies on first segment\n      result = intPtOnSegment(x3,y3,x1,y1,x2,y2,p) ||\n        intPtOnSegment(x4,y4,x1,y1,x2,y2,p);\n    }\n  } else {\n    x = ((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4))/denominator;\n    y = ((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4))/denominator;\n    // check int point (x,y) lies on both segment \n    result = intPtOnSegment(x,y,x1,y1,x2,y2,p) \n      && intPtOnSegment(x,y,x3,y3,x4,y4,p);\n  }\n  return result;\n} \n\nfunction intPtOnSegment(x,y,x1,y1,x2,y2,p) {\n  return fix(Math.min(x1,x2),p) <= fix(x,p) && fix(x,p) <= fix(Math.max(x1,x2),p) \n    && fix(Math.min(y1,y2),p) <= fix(y,p) && fix(y,p) <= fix(Math.max(y1,y2),p); \n}\n\n// fix to the precision\nfunction fix(n,p) {\n  return parseInt(n * Math.pow(10,p));\n}\n\nmodule.exports = linesIntersect;\n",
    "// rectangles-intersect.js\n// two rectangles (non aligned to axis) intersects or not\nvar linesIntersect = require('line-segments-intersect'),\n  pointInside = require('check-point-in-rectangle');\n\nfunction intersects(rect1,rect2) {\n  var intersect = rect1.some(function(pt1,i,r1) {\n    //check intersection of any seg or rect1 to any seg of rect2\n    var j = i == r1.length-1 ? 0 : i+1;\n    return rect2.some(function(pt2,k,r2) {\n      var l = k == r2.length-1 ? 0 : k+1;\n      return linesIntersect([r1[i], r1[j]], [r2[k], r2[l]]);\n    });\n  });\n  if(!intersect) {\n    // check one rectangle contains another\n    intersect = rect2.some(function(pt) {\n      return pointInside(pt, rect1);\n    }) ||\n    rect1.some(function(pt) {\n      return pointInside(pt, rect2);\n    });\n  }\n  return intersect;\n}\n\nmodule.exports = intersects;\n",
    "var Matrix = function() {\n    this.reset();\n};\nMatrix.prototype.reset = function() {\n    this.m = [1, 0, 0, 1, 0, 0];\n    return this;\n};\nMatrix.prototype.multiply = function(matrix) {\n    var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1],\n        m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1],\n        m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3],\n        m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];\n\n    var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4],\n        dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];\n    this.m[0] = m11;\n    this.m[1] = m12;\n    this.m[2] = m21;\n    this.m[3] = m22;\n    this.m[4] = dx;\n    this.m[5] = dy;\n    return this;\n};\nMatrix.prototype.inverse = function() {\n    var inv = new Matrix();\n    inv.m = this.m.slice(0);\n    var d = 1 / (inv.m[0] * inv.m[3] - inv.m[1] * inv.m[2]),\n        m0 = inv.m[3] * d,\n        m1 = -inv.m[1] * d,\n        m2 = -inv.m[2] * d,\n        m3 = inv.m[0] * d,\n        m4 = d * (inv.m[2] * inv.m[5] - inv.m[3] * inv.m[4]),\n        m5 = d * (inv.m[1] * inv.m[4] - inv.m[0] * inv.m[5]);\n    inv.m[0] = m0;\n    inv.m[1] = m1;\n    inv.m[2] = m2;\n    inv.m[3] = m3;\n    inv.m[4] = m4;\n    inv.m[5] = m5;\n    return inv;\n};\nMatrix.prototype.rotate = function(rad) {\n    var c = Math.cos(rad),\n        s = Math.sin(rad),\n        m11 = this.m[0] * c + this.m[2] * s,\n        m12 = this.m[1] * c + this.m[3] * s,\n        m21 = this.m[0] * -s + this.m[2] * c,\n        m22 = this.m[1] * -s + this.m[3] * c;\n    this.m[0] = m11;\n    this.m[1] = m12;\n    this.m[2] = m21;\n    this.m[3] = m22;\n    return this;\n};\nMatrix.prototype.translate = function(x, y) {\n    this.m[4] += this.m[0] * x + this.m[2] * y;\n    this.m[5] += this.m[1] * x + this.m[3] * y;\n    return this;\n};\nMatrix.prototype.scale = function(sx, sy) {\n    this.m[0] *= sx;\n    this.m[1] *= sx;\n    this.m[2] *= sy;\n    this.m[3] *= sy;\n    return this;\n};\nMatrix.prototype.transformPoint = function(px, py) {\n    var x = px,\n        y = py;\n    px = x * this.m[0] + y * this.m[2] + this.m[4];\n    py = x * this.m[1] + y * this.m[3] + this.m[5];\n    return [px, py];\n};\nMatrix.prototype.transformVector = function(px, py) {\n    var x = px,\n        y = py;\n    px = x * this.m[0] + y * this.m[2];\n    py = x * this.m[1] + y * this.m[3];\n    return [px, py];\n};\nif(typeof module !== \"undefined\") {\n    module.exports = Matrix;\n}\nelse {\n    window.Matrix = Matrix;\n}\n"
  ]
}